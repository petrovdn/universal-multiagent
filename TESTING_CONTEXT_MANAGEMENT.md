# Инструкция по тестированию контекстного управления

## Цель тестирования

Проверить, что система:
1. **Помнит контекст** между запросами
2. **Распознает референсы** ("этот файл", "та встреча")
3. **Использует уже полученные данные** вместо повторных запросов
4. **Понимает продолжения** диалога ("а теперь", "соберем все вместе")

## Подготовка

1. Убедитесь, что бэкенд-сервер запущен
2. Откройте фронтенд в браузере
3. Создайте новую сессию диалога
4. Убедитесь, что подключены необходимые интеграции (Google Drive, Calendar, Gmail, Sheets)

## Тестовые сценарии

### Сценарий 1: Референс к файлу

**Шаг 1:** Поиск файла
```
Запрос: "Найди файл test2 в Google Диск"
```

**Ожидаемое поведение:**
- Система находит файл
- Файл добавляется в entity memory
- В логах видно: `"Entity added to memory"` с типом `file`

**Шаг 2:** Референс к найденному файлу
```
Запрос: "Открой этот файл"
```

**Ожидаемое поведение:**
- ✅ Система использует найденный файл напрямую (по ID)
- ❌ НЕ планирует повторный поиск файла
- В плане должен быть шаг типа: "Открыть файл test2 (ID: ...)" или "Использовать найденный файл из контекста"
- В логах видно: `"Reference detected"` в task_classifier

**Проверка в логах:**
```bash
grep -i "reference detected" .cursor/debug.log
grep -i "entity added" .cursor/debug.log
grep -i "entity extraction" .cursor/debug.log
```

---

### Сценарий 2: Продолжение диалога

**Шаг 1:** Открытие файла
```
Запрос: "Найди и открой файл test2"
```

**Ожидаемое поведение:**
- Файл найден и открыт
- Содержимое файла показано пользователю
- Файл и его содержимое в контексте

**Шаг 2:** Продолжение с использованием контекста
```
Запрос: "Теперь сделай краткое содержание того, что было в файле"
```

**Ожидаемое поведение:**
- ✅ Система использует уже открытый файл и его содержимое
- ❌ НЕ планирует повторный поиск или открытие файла
- План должен содержать шаги типа: "Проанализировать содержимое файла test2 из предыдущего шага"
- В логах видно: `"Continuation detected"` в task_classifier

**Проверка в логах:**
```bash
grep -i "continuation detected" .cursor/debug.log
grep -i "entity context" .cursor/debug.log
```

---

### Сценарий 3: Референс к встрече

**Шаг 1:** Создание встречи
```
Запрос: "Создай встречу 'Планирование проекта' на завтра в 14:00"
```

**Ожидаемое поведение:**
- Встреча создана
- Встреча добавлена в entity memory
- В логах видно извлечение entity типа `meeting`

**Шаг 2:** Референс к встрече
```
Запрос: "Добавь участников к этой встрече"
```

**Ожидаемое поведение:**
- ✅ Система использует созданную встречу напрямую
- ❌ НЕ планирует повторный поиск встречи
- В логах видно: `"Reference detected"`

---

### Сценарий 4: Референс к письму

**Шаг 1:** Отправка письма
```
Запрос: "Отправь письмо на test@example.com с темой 'Тест'"
```

**Ожидаемое поведение:**
- Письмо отправлено
- Письмо добавлено в entity memory

**Шаг 2:** Референс к письму
```
Запрос: "Перешли это письмо на другой адрес"
```

**Ожидаемое поведение:**
- ✅ Система использует отправленное письмо
- ❌ НЕ планирует повторный поиск письма

---

### Сценарий 5: Множественные объекты одного типа

**Шаг 1:** Поиск нескольких файлов
```
Запрос: "Найди все файлы с названием 'report'"
```

**Ожидаемое поведение:**
- Найдено несколько файлов
- Все файлы добавлены в entity memory

**Шаг 2:** Референс к последнему файлу
```
Запрос: "Открой этот файл"
```

**Ожидаемое поведение:**
- ✅ Система использует последний упомянутый файл
- В entity context должен быть указан последний файл: `[Последний: filename]`

---

### Сценарий 6: Простая задача с контекстом

**Шаг 1:** Контекстный запрос
```
Запрос: "Найди файл test2"
```

**Шаг 2:** Простой запрос с референсом
```
Запрос: "А что в этом файле?"
```

**Ожидаемое поведение:**
- Задача классифицируется как SIMPLE (если нет сложных операций)
- Но система все равно использует контекст для понимания референса
- В логах видно: `"Context prepared for LLM"` с `has_entity_context: true`

---

## Проверка логов

### Ключевые события для проверки:

1. **Извлечение entity из результатов инструментов:**
```bash
grep "Extracting entities" .cursor/debug.log
grep "Entity extraction completed" .cursor/debug.log
```

2. **Распознавание референсов:**
```bash
grep "Reference detected" .cursor/debug.log
```

3. **Распознавание продолжений:**
```bash
grep "Continuation detected" .cursor/debug.log
```

4. **Передача entity context в планирование:**
```bash
grep "Plan generation context prepared" .cursor/debug.log
grep "has_entity_context.*true" .cursor/debug.log
```

5. **Использование контекста в простых задачах:**
```bash
grep "Context prepared for LLM" .cursor/debug.log
```

### Пример успешного лога:

```json
{"location":"entity_memory.py:extract_entities_from_tool_result","message":"Extracting entities","data":{"tool_name":"search_workspace_files","result_type":"str"}}
{"location":"entity_memory.py:extract_entities_from_tool_result","message":"Entity extraction completed","data":{"tool_name":"search_workspace_files","total_entities":1,"entity_types":["file"]}}
{"location":"entity_memory.py:add_reference","message":"Entity added to memory","data":{"entity_type":"file","entity_id":"...","name":"test2","total_entities":1}}
{"location":"task_classifier.py:_check_for_references","message":"Reference detected","data":{"pattern":"этот","user_request":"открой этот файл","has_entities":true}}
{"location":"step_orchestrator.py:_generate_plan","message":"Plan generation context prepared","data":{"recent_messages_count":2,"has_entity_context":true,"total_messages":4}}
```

## Критерии успеха

✅ **Система проходит тест, если:**

1. Референсы распознаются (`Reference detected` в логах)
2. Entity извлекаются из результатов инструментов (`Entity extraction completed`)
3. Entity context передается в планирование (`has_entity_context: true`)
4. План НЕ содержит повторных операций поиска/получения уже упомянутых объектов
5. Система использует ID объектов из контекста напрямую

❌ **Система НЕ проходит тест, если:**

1. Референсы не распознаются
2. Entity не извлекаются из результатов
3. План содержит повторный поиск уже найденных объектов
4. Entity context не передается в LLM

## Отладка

Если тесты не проходят:

1. **Проверьте логи:**
   ```bash
   tail -f .cursor/debug.log | grep -E "(entity|reference|continuation|context)"
   ```

2. **Проверьте entity memory:**
   - Убедитесь, что `add_entity_from_tool_result` вызывается после каждого tool execution
   - Проверьте формат результатов инструментов

3. **Проверьте промпты:**
   - Убедитесь, что entity context добавляется в messages для планирования
   - Проверьте, что промпт содержит универсальные инструкции

4. **Проверьте парсинг:**
   - Убедитесь, что `extract_entities_from_tool_result` правильно парсит строковые результаты
   - Проверьте регулярные выражения для извлечения ID и имен

## Дополнительные тесты

### Тест производительности:
- Создайте диалог с 10+ сообщениями
- Проверьте, что контекст не разрастается чрезмерно
- Убедитесь, что `short_term_window` ограничивает количество сообщений

### Тест с разными типами объектов:
- Протестируйте с файлами, встречами, письмами, таблицами
- Убедитесь, что система работает универсально для всех типов

### Тест с несколькими пользователями:
- Откройте 2-3 сессии одновременно
- Убедитесь, что контекст изолирован между сессиями

